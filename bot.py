import osimport asyncioimport loggingfrom datetime import datetime, timedeltaimport pytzfrom dotenv import load_dotenvfrom typing import Dict, Any, Optionalfrom aiogram import Bot, Dispatcher, types, Ffrom aiogram.filters import Command, CommandStartfrom aiogram.fsm.storage.memory import MemoryStoragefrom aiogram.fsm.context import FSMContextfrom aiogram.fsm.state import StatesGroup, Statefrom aiogram.enums import ParseModefrom aiogram.client.default import DefaultBotPropertiesfrom aiogram.types import (    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove,    InlineKeyboardMarkup, InlineKeyboardButton)from google.cloud import firestoreimport google.generativeai as genaifrom apscheduler.schedulers.asyncio import AsyncIOSchedulerimport io# ==================== Project Directory Setup ====================PROJECT_DIR = os.path.dirname(os.path.abspath(__file__))CREDENTIALS_DIR = os.path.join(PROJECT_DIR, "credentials")os.makedirs(CREDENTIALS_DIR, exist_ok=True)# ==================== Translations ====================TRANSLATIONS = {    "intro": {        "en": "üëã Hello! I am NutritionBot. Please select your language:",        "ru": "üëã –ü—Ä–∏–≤–µ—Ç! –Ø NutritionBot. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",        "uz": "üëã Salom! Men NutritionBot. Tilni tanlang:"    },    "select_language": {        "en": "Choose your language:",        "ru": "–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —è–∑—ã–∫:",        "uz": "Tilni tanlang:"    },    "ask_name": {        "en": "Enter your name:",        "ru": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è:",        "uz": "Ismingizni kiriting:"    },    "name_error": {        "en": "Name should be between 2 and 50 characters.",        "ru": "–ò–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 2 –¥–æ 50 —Å–∏–º–≤–æ–ª–æ–≤.",        "uz": "Ism 2 dan 50 belgigacha bo'lishi kerak."    },    "ask_age": {        "en": "Enter your age:",        "ru": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–∑—Ä–∞—Å—Ç:",        "uz": "Yoshingizni kiriting:"    },    "age_error": {        "en": "Please enter a valid age between 0 and 120",        "ru": "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç –æ—Ç 0 –¥–æ 120",        "uz": "Iltimos, 0 dan 120 gacha yoshingizni kiriting"    },    "ask_height": {        "en": "Enter your height (cm):",        "ru": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à —Ä–æ—Å—Ç (—Å–º):",        "uz": "Bo'yingizni kiriting (sm):"    },    "height_error": {        "en": "Please enter a valid height between 50 and 250 cm",        "ru": "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–æ—Å—Ç –æ—Ç 50 –¥–æ 250 —Å–º",        "uz": "Iltimos, 50 dan 250 sm gacha bo'yingizni kiriting"    },    "ask_weight": {        "en": "Enter your weight (kg):",        "ru": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–µ—Å (–∫–≥):",        "uz": "Vazningizni kiriting (kg):"    },    "weight_error": {        "en": "Please enter a valid weight between 20 and 300 kg",        "ru": "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤–µ—Å –æ—Ç 20 –¥–æ 300 –∫–≥",        "uz": "Iltimos, 20 dan 300 kg gacha vazningizni kiriting"    },    "ask_gender": {        "en": "Select your gender:",        "ru": "–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à –ø–æ–ª:",        "uz": "Jinsingizni tanlang:"    },    "ask_timezone": {        "en": "Select or enter your timezone:",        "ru": "–í—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å:",        "uz": "Vaqt mintaqangizni tanlang yoki kiriting:"    },    "timezone_error": {        "en": "Invalid timezone. Please select one from the buttons or enter a valid timezone",        "ru": "–ù–µ–≤–µ—Ä–Ω—ã–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å. –í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ –∫–Ω–æ–ø–æ–∫ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å",        "uz": "Noto'g'ri vaqt mintaqasi. Tugmalardan tanlang yoki to'g'ri vaqt mintaqasini kiriting"    },    "ask_goal": {        "en": "(Optional) Select or enter your goal:",        "ru": "(–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) –í—ã–±–µ—Ä–∏—Ç–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à—É —Ü–µ–ª—å:",        "uz": "(Ixtiyoriy) Maqsadingizni tanlang yoki kiriting:"    },    "registration_complete": {        "en": "‚úÖ Registration complete! Send me food info or photos.",        "ru": "‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –µ–¥–µ.",        "uz": "‚úÖ Ro'yxatdan o'tish yakunlandi! Ovqat haqida ma'lumot yuboring."    },    "water_reminder": {        "en": "üíß Time to drink water! Stay hydrated!",        "ru": "üíß –í—Ä–µ–º—è –ø–∏—Ç—å –≤–æ–¥—É! –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ –≤–æ–¥–Ω—ã–π –±–∞–ª–∞–Ω—Å!",        "uz": "üíß Suv ichish vaqti! Suv miqdorini saqlang!"    },    "meal_reminder": {        "en": "‚è∞ Don't forget to log your meal!",        "ru": "‚è∞ –ù–µ –∑–∞–±—É–¥—å—Ç–µ –∑–∞–ø–∏—Å–∞—Ç—å —Å–≤–æ–π –ø—Ä–∏–µ–º –ø–∏—â–∏!",        "uz": "‚è∞ Ovqatlanishingizni kiritishni unutmang!"    },    "reminder_set": {        "en": "‚è∞ Reminder set successfully for {time}",        "ru": "‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ {time}",        "uz": "‚è∞ Eslatma {time} da muvaffaqiyatli o'rnatildi"    },    "water_logged": {        "en": "‚úÖ Water intake recorded! +250ml",        "ru": "‚úÖ –ü—Ä–∏–µ–º –≤–æ–¥—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω! +250–º–ª",        "uz": "‚úÖ Suv miqdori qayd etildi! +250ml"    },    "processing": {        "en": "‚è≥ Processing your request...",        "ru": "‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à –∑–∞–ø—Ä–æ—Å...",        "uz": "‚è≥ So'rovingiz bajarilmoqda..."    },    "error_processing": {        "en": "‚ùå Error processing your request. Please try again.",        "ru": "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",        "uz": "‚ùå So'rovni qayta ishlashda xatolik. Iltimos, qaytadan urinib ko'ring."    },    "main_menu": {        "en": "üìã Main Menu - What would you like to do?",        "ru": "üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é - –ß—Ç–æ –±—ã –≤—ã —Ö–æ—Ç–µ–ª–∏ —Å–¥–µ–ª–∞—Ç—å?",        "uz": "üìã Asosiy menyu - Nima qilmoqchisiz?"    },    "menu_log_water": {        "en": "üíß Log Water",        "ru": "üíß –ó–∞–ø–∏—Å–∞—Ç—å –≤–æ–¥—É",        "uz": "üíß Suv qayd etish"    },    "menu_stats": {        "en": "üìä My Stats",        "ru": "üìä –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",        "uz": "üìä Mening statistikam"    },    "menu_settings": {        "en": "‚öôÔ∏è Settings",        "ru": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",        "uz": "‚öôÔ∏è Sozlamalar"    },    "menu_log_meal": {        "en": "üçΩ Log Meal",        "ru": "üçΩ –ó–∞–ø–∏—Å–∞—Ç—å –ø—Ä–∏–µ–º –ø–∏—â–∏",        "uz": "üçΩ Ovqat qayd etish"    },    "menu_help": {        "en": "‚ùì Help",        "ru": "‚ùì –ü–æ–º–æ—â—å",        "uz": "‚ùì Yordam"    },    "help_text": {        "en": "üåü <b>How to Use NutritionBot:</b>\n\n"              "‚Ä¢ <b>Log Meals:</b> Send a photo of your food or text describing what you ate\n"              "‚Ä¢ <b>Log Water:</b> Use the üíß button or /water command\n"              "‚Ä¢ <b>View Stats:</b> Use the üìä button or /stats command\n"              "‚Ä¢ <b>Main Menu:</b> Use /menu command anytime\n\n"              "For more assistance, contact @jurat1",        "ru": "üåü <b>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å NutritionBot:</b>\n\n"              "‚Ä¢ <b>–ó–∞–ø–∏—Å—å –ø–∏—Ç–∞–Ω–∏—è:</b> –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –µ–¥—ã –∏–ª–∏ —Ç–µ–∫—Å—Ç —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º\n"              "‚Ä¢ <b>–ó–∞–ø–∏—Å—å –≤–æ–¥—ã:</b> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É üíß –∏–ª–∏ –∫–æ–º–∞–Ω–¥—É /water \n"              "‚Ä¢ <b>–ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:</b> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É üìä –∏–ª–∏ –∫–æ–º–∞–Ω–¥—É /stats\n"              "‚Ä¢ <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:</b> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /menu –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç\n\n"              "–î–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –ø–æ–º–æ—â–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ @jurat1",        "uz": "üåü <b>NutritionBot-dan qanday foydalanish mumkin:</b>\n\n"              "‚Ä¢ <b>Ovqatni qayd etish:</b> Ovqatning rasmini yoki tavsifini yuboring\n"              "‚Ä¢ <b>Suvni qayd etish:</b> üíß tugmasini yoki /water buyrug'ini ishlating\n"              "‚Ä¢ <b>Statistikani ko'rish:</b> üìä tugmasini yoki /stats buyrug'ini ishlating\n"              "‚Ä¢ <b>Asosiy menyu:</b> Istalgan vaqtda /menu buyrug'ini ishlating\n\n"              "Qo'shimcha yordam uchun @jurat1 ga murojaat qiling"    },    "male": {        "en": "Male",        "ru": "–ú—É–∂—Å–∫–æ–π",        "uz": "Erkak"    },    "female": {        "en": "Female",        "ru": "–ñ–µ–Ω—Å–∫–∏–π",        "uz": "Ayol"    },    "settings_title": {        "en": "‚öôÔ∏è Settings",        "ru": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",        "uz": "‚öôÔ∏è Sozlamalar"    },    "change_language": {        "en": "üî§ Change Language",        "ru": "üî§ –ò–∑–º–µ–Ω–∏—Ç—å —è–∑—ã–∫",        "uz": "üî§ Tilni o'zgartirish"    },    "edit_reminders": {        "en": "‚è∞ Edit Reminders",        "ru": "‚è∞ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è",        "uz": "‚è∞ Eslatmalarni tahrirlash"    },    "edit_profile": {        "en": "üë§ Edit Profile",        "ru": "üë§ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å",        "uz": "üë§ Profilni tahrirlash"    },    "back_to_menu": {        "en": "üîô Back to Menu",        "ru": "üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é",        "uz": "üîô Menyuga qaytish"    },    "select_new_language": {        "en": "Select your new language:",        "ru": "–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—ã–π —è–∑—ã–∫:",        "uz": "Yangi tilni tanlang:"    },    "language_changed": {        "en": "‚úÖ Language changed successfully!",        "ru": "‚úÖ –Ø–∑—ã–∫ —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω!",        "uz": "‚úÖ Til muvaffaqiyatli o'zgartirildi!"    },    "edit_which_field": {        "en": "Select field to edit:",        "ru": "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:",        "uz": "Tahrirlash uchun maydonni tanlang:"    },    "edit_name": {        "en": "‚úèÔ∏è Name",        "ru": "‚úèÔ∏è –ò–º—è",        "uz": "‚úèÔ∏è Ism"    },    "edit_age": {        "en": "‚úèÔ∏è Age",        "ru": "‚úèÔ∏è –í–æ–∑—Ä–∞—Å—Ç",        "uz": "‚úèÔ∏è Yosh"    },    "edit_goal": {        "en": "‚úèÔ∏è Goal",        "ru": "‚úèÔ∏è –¶–µ–ª—å",        "uz": "‚úèÔ∏è Maqsad"    },    "reminder_settings": {        "en": "‚è∞ Reminder Settings\n\nWater reminders: {water_status}\nMeal reminders: {meal_status}",        "ru": "‚è∞ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π\n\n–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –≤–æ–¥–µ: {water_status}\n–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –µ–¥–µ: {meal_status}",        "uz": "‚è∞ Eslatma sozlamalari\n\nSuv eslatmalari: {water_status}\nOvqat eslatmalari: {meal_status}"    },    "toggle_water_reminders": {        "en": "üíß Toggle Water Reminders",        "ru": "üíß –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –≤–æ–¥–µ",        "uz": "üíß Suv eslatmalarini yoqish/o'chirish"    },    "toggle_meal_reminders": {        "en": "üçΩ Toggle Meal Reminders",        "ru": "üçΩ –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –µ–¥–µ",        "uz": "üçΩ Ovqat eslatmalarini yoqish/o'chirish"    },    "reminder_enabled": {        "en": "‚úÖ Enabled",        "ru": "‚úÖ –í–∫–ª—é—á–µ–Ω—ã",        "uz": "‚úÖ Yoqilgan"    },    "reminder_disabled": {        "en": "‚ùå Disabled",        "ru": "‚ùå –í—ã–∫–ª—é—á–µ–Ω—ã",        "uz": "‚ùå O'chirilgan"    },    "enter_new_value": {        "en": "Enter new value:",        "ru": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:",        "uz": "Yangi qiymatni kiriting:"    },    "profile_updated": {        "en": "‚úÖ Profile updated successfully!",        "ru": "‚úÖ –ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!",        "uz": "‚úÖ Profil muvaffaqiyatli yangilandi!"    },    "food_analysis": {        "en": "Food Analysis",        "ru": "–ê–Ω–∞–ª–∏–∑ –µ–¥—ã",        "uz": "Ovqat tahlili"    },    "stats_header": {        "en": "Your Statistics",        "ru": "–í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",        "uz": "Statistikangiz"    },    "today_summary": {        "en": "Today's Summary",        "ru": "–°–≤–æ–¥–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è",        "uz": "Bugungi xulosa"    },    "water": {        "en": "Water",        "ru": "–í–æ–¥–∞",        "uz": "Suv"    },    "meals_today": {        "en": "Meals logged today",        "ru": "–ü—Ä–∏–µ–º—ã –ø–∏—â–∏ —Å–µ–≥–æ–¥–Ω—è",        "uz": "Bugun qayd etilgan ovqatlar"    },    "total_stats": {        "en": "Total Stats",        "ru": "–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",        "uz": "Umumiy statistika"    },    "total_water": {        "en": "Total Water",        "ru": "–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–¥—ã",        "uz": "Umumiy suv"    },    "total_meals": {        "en": "Total Meals Logged",        "ru": "–í—Å–µ–≥–æ –∑–∞–ø–∏—Å–∞–Ω–æ –ø—Ä–∏–µ–º–æ–≤ –ø–∏—â–∏",        "uz": "Jami qayd etilgan ovqatlar"    },    "bmi": {        "en": "BMI",        "ru": "–ò–ú–¢",        "uz": "TVI"    },    "breakfast": {        "en": "üç≥ Breakfast",        "ru": "üç≥ –ó–∞–≤—Ç—Ä–∞–∫",        "uz": "üç≥ Nonushta"    },    "lunch": {        "en": "ü•™ Lunch",        "ru": "ü•™ –û–±–µ–¥",        "uz": "ü•™ Tushlik"    },    "dinner": {        "en": "üçΩ Dinner",        "ru": "üçΩ –£–∂–∏–Ω",        "uz": "üçΩ Kechki ovqat"    },    "snack": {        "en": "üç´ Snack",        "ru": "üç´ –ü–µ—Ä–µ–∫—É—Å",        "uz": "üç´ Gazak"    },    "select_meal_type": {        "en": "Select meal type:",        "ru": "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø—Ä–∏–µ–º–∞ –ø–∏—â–∏:",        "uz": "Ovqat turini tanlang:"    }}def t(key: str, lang: str) -> str:    return TRANSLATIONS.get(key, {}).get(lang, TRANSLATIONS.get(key, {}).get("en", key))# ==================== Initialize Services ====================load_dotenv()# Firestore Databasetry:    db = firestore.Client()except Exception as e:    logging.error(f"Failed to initialize Firestore: {e}")    os.environ["FIRESTORE_EMULATOR_HOST"] = "localhost:8080"    db = firestore.Client(project="nutrition-bot-local")def get_user_ref(user_id: int):    return db.collection('users').document(str(user_id))def get_meals_ref(user_id: int):    return get_user_ref(user_id).collection('meals')def get_water_ref(user_id: int):    return get_user_ref(user_id).collection('water')# Gemini AItry:    genai.configure(api_key=os.getenv("GEMINI_API_KEY"))    nutrition_model = genai.GenerativeModel('gemini-1.5-flash-latest')    vision_model = genai.GenerativeModel('gemini-1.5-flash-latest')except Exception as e:    logging.error(f"Failed to initialize Gemini AI: {e}")# ==================== Bot Setup ====================bot = Bot(token=os.getenv("BOT_TOKEN"), default=DefaultBotProperties(parse_mode=ParseMode.HTML))storage = MemoryStorage()dp = Dispatcher(storage=storage)scheduler = AsyncIOScheduler()logger = logging.getLogger(__name__)# ==================== States ====================class SettingsStates(StatesGroup):    changing_language = State()    editing_profile = State()    editing_reminders = State()class EditProfileStates(StatesGroup):    selecting_field = State()    editing_name = State()    editing_age = State()    editing_height = State()    editing_weight = State()    editing_goal = State()class EditRemindersStates(StatesGroup):    main_menu = State()    toggling_water = State()    toggling_meal = State()class Registration(StatesGroup):    language = State()    name = State()    age = State()    height = State()    weight = State()    gender = State()    timezone = State()    goal = State()class ReminderStates(StatesGroup):    setting_water = State()    setting_meal = State()class MealLogging(StatesGroup):    waiting_for_text = State()# ==================== Keyboard Functions ====================def get_language_keyboard():    return ReplyKeyboardMarkup(        keyboard=[            [KeyboardButton(text="üá∫üáø O'zbek"), KeyboardButton(text="üá∑üá∫ –†—É—Å—Å–∫–∏–π")],            [KeyboardButton(text="üá¨üáß English")]        ],        resize_keyboard=True,        one_time_keyboard=True    )def get_gender_keyboard(lang: str):    return ReplyKeyboardMarkup(        keyboard=[            [KeyboardButton(text=t("male", lang)), KeyboardButton(text=t("female", lang))]        ],        resize_keyboard=True,        one_time_keyboard=True    )def get_timezone_keyboard():    return ReplyKeyboardMarkup(        keyboard=[            [KeyboardButton(text="Asia/Tashkent"), KeyboardButton(text="Europe/Moscow")],            [KeyboardButton(text="Europe/London"), KeyboardButton(text="America/New_York")]        ],        resize_keyboard=True,        one_time_keyboard=True    )def get_goals_keyboard(lang: str):    goals_by_lang = {        "en": ["Skip", "Lose weight", "Gain muscle", "Eat healthier"],        "ru": ["–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", "–ü–æ—Ö—É–¥–µ—Ç—å", "–ù–∞–±—Ä–∞—Ç—å –º–∞—Å—Å—É", "–ü–∏—Ç–∞—Ç—å—Å—è –∑–¥–æ—Ä–æ–≤–µ–µ"],        "uz": ["O'tkaz", "Vazn yo'qotish", "Massa oshirish", "Sog'lom ovqat"]    }    buttons = [KeyboardButton(text=label) for label in goals_by_lang.get(lang, goals_by_lang["en"])]    return ReplyKeyboardMarkup(        keyboard=[buttons],        resize_keyboard=True,        one_time_keyboard=True    )def get_main_menu_keyboard(lang: str):    return ReplyKeyboardMarkup(        keyboard=[            [KeyboardButton(text=t("menu_log_meal", lang)), KeyboardButton(text=t("menu_log_water", lang))],            [KeyboardButton(text=t("menu_stats", lang)), KeyboardButton(text=t("menu_settings", lang))],            [KeyboardButton(text=t("menu_help", lang))]        ],        resize_keyboard=True    )# ==================== Helper Functions ====================async def get_user_language(user_id: int) -> str:    """Get user language from Firestore or default to English"""    try:        user_ref = get_user_ref(user_id)        user_data = user_ref.get().to_dict()        return user_data.get('language', 'en') if user_data else 'en'    except Exception as e:        logger.error(f"Error getting user language: {e}")        return 'en'# ==================== Reminder Functions ====================async def schedule_default_reminders(user_id: int, timezone: str):    """Schedule default water and meal reminders"""    try:        user_data = get_user_ref(user_id).get().to_dict()        if not user_data.get('water_reminders', True):            return        # Water reminders every 2 hours from 8 AM to 10 PM        for hour in range(8, 22, 2):            scheduler.add_job(                send_water_reminder,                'cron',                hour=hour,                timezone=timezone,                args=[user_id],                id=f"water_{user_id}_{hour}",                replace_existing=True            )        # Meal reminders        meal_times = [("09:00", "breakfast"), ("13:00", "lunch"), ("19:00", "dinner")]        for time, meal_type in meal_times:            hour, minute = map(int, time.split(':'))            scheduler.add_job(                send_meal_reminder,                'cron',                hour=hour,                minute=minute,                timezone=timezone,                args=[user_id, meal_type],                id=f"meal_{user_id}_{meal_type}",                replace_existing=True            )        logger.info(f"Scheduled reminders for user {user_id}")    except Exception as e:        logger.error(f"Error scheduling reminders: {e}")async def send_water_reminder(user_id: int):    """Send water reminder to user"""    try:        user_lang = await get_user_language(user_id)        message = t("water_reminder", user_lang)        # Create inline keyboard for quick water logging        keyboard = InlineKeyboardMarkup(            inline_keyboard=[                [                    InlineKeyboardButton(text="‚úÖ Log Water", callback_data="log_water")                ]            ]        )        await bot.send_message(user_id, message, reply_markup=keyboard)    except Exception as e:        logger.error(f"Error sending water reminder: {e}")async def send_meal_reminder(user_id: int, meal_type: str):    """Send meal reminder to user"""    try:        user_lang = await get_user_language(user_id)        emoji_map = {"breakfast": "üç≥", "lunch": "üç≤", "dinner": "üçΩ"}        emoji = emoji_map.get(meal_type, "üçî")        message = f"{emoji} {t('meal_reminder', user_lang)} ({meal_type})"        # Create inline keyboard for quick meal logging        keyboard = InlineKeyboardMarkup(            inline_keyboard=[                [                    InlineKeyboardButton(text="üìù Text", callback_data=f"log_meal_text_{meal_type}"),                    InlineKeyboardButton(text="üì∑ Photo", callback_data=f"log_meal_photo_{meal_type}")                ]            ]        )        await bot.send_message(user_id, message, reply_markup=keyboard)    except Exception as e:        logger.error(f"Error sending meal reminder: {e}")# ==================== Handlers ====================@dp.message(CommandStart())async def cmd_start(message: types.Message, state: FSMContext):    """Handle /start command"""    await state.clear()    await message.answer(t("intro", "en"), reply_markup=get_language_keyboard())    await state.set_state(Registration.language)@dp.message(Command("menu"))async def cmd_menu(message: types.Message):    """Handle /menu command"""    user_id = message.from_user.id    lang = await get_user_language(user_id)    await message.answer(t("main_menu", lang), reply_markup=get_main_menu_keyboard(lang))@dp.message(Command("help"))async def cmd_help(message: types.Message):    """Handle /help command"""    user_id = message.from_user.id    lang = await get_user_language(user_id)    await message.answer(t("help_text", lang))@dp.message(Registration.language)async def reg_language(message: types.Message, state: FSMContext):    """Handle language selection during registration"""    text = message.text.lower()    if "o'zbek" in text or "uzbek" in text or "üá∫üáø" in text:        lang = "uz"    elif "—Ä—É—Å" in text or "rus" in text or "üá∑üá∫" in text:        lang = "ru"    elif "english" in text or "üá¨üáß" in text:        lang = "en"    else:        return await message.answer(t("select_language", "en"))    await state.update_data(language=lang)    await message.answer(t("ask_name", lang), reply_markup=ReplyKeyboardRemove())    await state.set_state(Registration.name)@dp.message(Registration.name)async def reg_name(message: types.Message, state: FSMContext):    """Handle name input during registration"""    data = await state.get_data()    lang = data.get("language", "en")    name = message.text.strip()    if len(name) < 2 or len(name) > 50:        return await message.answer(t("name_error", lang))    await state.update_data(name=name)    await message.answer(t("ask_age", lang))    await state.set_state(Registration.age)@dp.message(Registration.age)async def reg_age(message: types.Message, state: FSMContext):    """Handle age input during registration"""    data = await state.get_data()    lang = data.get("language", "en")    try:        age = int(message.text.strip())        if not 0 <= age <= 120:            return await message.answer(t("age_error", lang))        await state.update_data(age=age)        await message.answer(t("ask_height", lang))        await state.set_state(Registration.height)    except ValueError:        await message.answer(t("age_error", lang))@dp.message(Registration.height)async def reg_height(message: types.Message, state: FSMContext):    """Handle height input during registration"""    data = await state.get_data()    lang = data.get("language", "en")    try:        height = float(message.text.strip())        if not 50 <= height <= 250:            return await message.answer(t("height_error", lang))        await state.update_data(height=height)        await message.answer(t("ask_weight", lang))        await state.set_state(Registration.weight)    except ValueError:        await message.answer(t("height_error", lang))@dp.message(Registration.weight)async def reg_weight(message: types.Message, state: FSMContext):    """Handle weight input during registration"""    data = await state.get_data()    lang = data.get("language", "en")    try:        weight = float(message.text.strip())        if not 20 <= weight <= 300:            return await message.answer(t("weight_error", lang))        await state.update_data(weight=weight)        await message.answer(t("ask_gender", lang), reply_markup=get_gender_keyboard(lang))        await state.set_state(Registration.gender)    except ValueError:        await message.answer(t("weight_error", lang))@dp.message(Registration.gender)async def reg_gender(message: types.Message, state: FSMContext):    """Handle gender selection during registration"""    data = await state.get_data()    lang = data.get("language", "en")    gender_map = {        "en": {"male": ["male"], "female": ["female"]},        "ru": {"male": ["–º—É–∂—á–∏–Ω–∞", "–º—É–∂—Å–∫–æ–π"], "female": ["–∂–µ–Ω—â–∏–Ω–∞", "–∂–µ–Ω—Å–∫–∏–π"]},        "uz": {"male": ["erkak"], "female": ["ayol"]}    }    text = message.text.strip().lower()    gender = None    for g, terms in gender_map.get(lang, gender_map["en"]).items():        if any(term.lower() in text.lower() for term in terms):            gender = g            break    if not gender:        return await message.answer(t("ask_gender", lang), reply_markup=get_gender_keyboard(lang))    await state.update_data(gender=gender)    await message.answer(t("ask_timezone", lang), reply_markup=get_timezone_keyboard())    await state.set_state(Registration.timezone)@dp.message(Registration.timezone)async def reg_timezone(message: types.Message, state: FSMContext):    """Handle timezone selection during registration"""    data = await state.get_data()    lang = data.get("language", "en")    try:        tz = pytz.timezone(message.text.strip())        await state.update_data(timezone=str(tz))        await message.answer(t("ask_goal", lang), reply_markup=get_goals_keyboard(lang))        await state.set_state(Registration.goal)    except pytz.exceptions.UnknownTimeZoneError:        await message.answer(t("timezone_error", lang))@dp.message(Registration.goal)async def reg_goal(message: types.Message, state: FSMContext):    """Handle goal selection and complete registration"""    try:        data = await state.get_data()        lang = data.get("language", "en")        goal = message.text.strip()        # Skip values in different languages        skip_values = ["Skip", "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", "O'tkaz"]        goal_value = "" if goal in skip_values else goal        # Save to Firestore        user_ref = get_user_ref(message.from_user.id)        user_data = {            **data,            'goal': goal_value,            'registered_at': datetime.now(pytz.utc),            'telegram_username': message.from_user.username,            'telegram_id': message.from_user.id,            'last_active': datetime.now(pytz.utc)        }        user_ref.set(user_data)        # Schedule reminders        await schedule_default_reminders(message.from_user.id, data['timezone'])        # Show completion message and main menu        await message.answer(t("registration_complete", lang), reply_markup=get_main_menu_keyboard(lang))        await state.clear()    except Exception as e:        logger.error(f"Registration error: {e}")        await message.answer("‚ùå Registration failed. Please try /start again")        await state.clear()@dp.message(F.text.lower() == "üíß log water")@dp.message(F.text.lower() == "üíß –∑–∞–ø–∏—Å–∞—Ç—å –≤–æ–¥—É")@dp.message(F.text.lower() == "üíß suv qayd etish")@dp.message(Command("water"))async def log_water(message: types.Message):    """Handle water logging through command or menu button"""    try:        user_id = message.from_user.id        lang = await get_user_language(user_id)        # Update user's last active timestamp        get_user_ref(user_id).update({            'last_active': datetime.now(pytz.utc)        })        # Log default water amount (250ml)        get_water_ref(user_id).add({            'amount': 250,            'timestamp': datetime.now(pytz.utc)        })        await message.answer(t("water_logged", lang))    except Exception as e:        logger.error(f"Water logging error: {e}")        lang = await get_user_language(message.from_user.id)        await message.answer(t("error_processing", lang))@dp.callback_query(lambda c: c.data == "log_water")async def callback_log_water(callback_query: types.CallbackQuery):    """Handle water logging through inline button"""    try:        user_id = callback_query.from_user.id        lang = await get_user_language(user_id)        # Update user's last active timestamp        get_user_ref(user_id).update({            'last_active': datetime.now(pytz.utc)        })        # Log default water amount (250ml)        get_water_ref(user_id).add({            'amount': 250,            'timestamp': datetime.now(pytz.utc)        })        await callback_query.answer("Water logged successfully!")        await bot.send_message(user_id, t("water_logged", lang))    except Exception as e:        logger.error(f"Water logging error from callback: {e}")        lang = await get_user_language(callback_query.from_user.id)        await bot.send_message(callback_query.from_user.id, t("error_processing", lang))@dp.message(F.text.lower() == "üìä my stats")@dp.message(F.text.lower() == "üìä –º–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")@dp.message(F.text.lower() == "üìä mening statistikam")@dp.message(Command("stats"))async def show_stats(message: types.Message):    """Handle stats display through command or menu button and display nutrition statistics"""    try:        user_id = message.from_user.id        lang = await get_user_language(user_id)        # Update user's last active timestamp        get_user_ref(user_id).update({            'last_active': datetime.now(pytz.utc)        })        # Processing message        await message.answer(t("processing", lang))        # Get user data        user_ref = get_user_ref(user_id)        user_data = user_ref.get().to_dict()        if not user_data:            return await message.answer("‚ùå User data not found. Please register with /start")        # Water stats - Calculate daily and total water intake        today = datetime.now(pytz.timezone(user_data.get('timezone', 'UTC'))).date()        today_start = datetime.combine(today, datetime.min.time(),                                       tzinfo=pytz.timezone(user_data.get('timezone', 'UTC')))        today_end = datetime.combine(today, datetime.max.time(), tzinfo=pytz.timezone(user_data.get('timezone', 'UTC')))        # Convert to UTC for Firestore query        today_start_utc = today_start.astimezone(pytz.UTC)        today_end_utc = today_end.astimezone(pytz.UTC)        # Get water logs        all_water_docs = list(get_water_ref(user_id).stream())        # Calculate total water intake        total_water = sum(doc.to_dict().get('amount', 0) for doc in all_water_docs)        # Calculate today's water intake        today_water_docs = list(get_water_ref(user_id)                                .where('timestamp', '>=', today_start_utc)                                .where('timestamp', '<=', today_end_utc)                                .stream())        today_water = sum(doc.to_dict().get('amount', 0) for doc in today_water_docs)        # Meal stats        all_meal_docs = list(get_meals_ref(user_id).stream())        total_meals = len(all_meal_docs)        # Today's meals        today_meal_docs = list(get_meals_ref(user_id)                               .where('timestamp', '>=', today_start_utc)                               .where('timestamp', '<=', today_end_utc)                               .stream())        today_meals = len(today_meal_docs)        # Calculate recommended water intake based on weight        weight = user_data.get('weight', 70)        recommended_water = int(weight * 30)  # 30ml per kg body weight        # Calculate water percentage of daily goal        water_percentage = min(int((today_water / recommended_water) * 100), 100) if recommended_water > 0 else 0        # Create progress bar for water intake        progress_bar_length = 10        filled_blocks = int((water_percentage / 100) * progress_bar_length)        empty_blocks = progress_bar_length - filled_blocks        progress_bar = "üü¶" * filled_blocks + "‚¨ú" * empty_blocks        # Format response        response = (            f"üìä <b>{t('stats_header', lang)}:</b>\n\n"            f"<b>{t('today_summary', lang)} ({today.strftime('%Y-%m-%d')}):</b>\n"            f"üíß <b>{t('water', lang)}:</b> {today_water}ml / {recommended_water}ml\n"            f"{progress_bar} {water_percentage}%\n"            f"üçΩ <b>{t('meals_today', lang)}:</b> {today_meals}\n\n"            f"<b>{t('total_stats', lang)}:</b>\n"            f"üíß <b>{t('total_water', lang)}:</b> {total_water}ml\n"            f"üçΩ <b>{t('total_meals', lang)}:</b> {total_meals}\n"        )        # Add BMI if we have height and weight        if 'height' in user_data and 'weight' in user_data:            height_m = user_data['height'] / 100  # convert cm to m            bmi = user_data['weight'] / (height_m * height_m)            bmi_categories = {                "en": {"underweight": "Underweight", "normal": "Normal weight", "overweight": "Overweight", "obesity": "Obesity"},                "ru": {"underweight": "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –≤–µ—Å", "normal": "–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –≤–µ—Å", "overweight": "–ò–∑–±—ã—Ç–æ—á–Ω—ã–π –≤–µ—Å", "obesity": "–û–∂–∏—Ä–µ–Ω–∏–µ"},                "uz": {"underweight": "Kam vazn", "normal": "Normal vazn", "overweight": "Ortiqcha vazn", "obesity": "Semizlik"}            }            if bmi < 18.5:                category = bmi_categories[lang]["underweight"]            elif 18.5 <= bmi < 25:                category = bmi_categories[lang]["normal"]            elif 25 <= bmi < 30:                category = bmi_categories[lang]["overweight"]            else:                category = bmi_categories[lang]["obesity"]            response += f"\n<b>{t('bmi', lang)}:</b> {bmi:.1f} ({category})"        await message.answer(response, reply_markup=get_main_menu_keyboard(lang))    except Exception as e:        logger.error(f"Stats error: {e}")        lang = await get_user_language(message.from_user.id)        await message.answer(t("error_processing", lang), reply_markup=get_main_menu_keyboard(lang))@dp.message(F.text.lower() == "‚ùì help")@dp.message(F.text.lower() == "‚ùì –ø–æ–º–æ—â—å")@dp.message(F.text.lower() == "‚ùì yordam")async def show_help(message: types.Message):    """Show help information"""    user_id = message.from_user.id    lang = await get_user_language(user_id)    await message.answer(t("help_text", lang), reply_markup=get_main_menu_keyboard(lang))@dp.callback_query(lambda c: c.data == "change_language")async def change_language_callback(callback: types.CallbackQuery, state: FSMContext):    user_id = callback.from_user.id    lang = await get_user_language(user_id)    await state.set_state(SettingsStates.changing_language)    await callback.message.edit_text(        t("select_new_language", lang),        reply_markup=get_language_keyboard()    )@dp.message(SettingsStates.changing_language)async def handle_new_language(message: types.Message, state: FSMContext):    user_id = message.from_user.id    text = message.text.lower()    if "o'zbek" in text or "uzbek" in text or "üá∫üáø" in text:        new_lang = "uz"    elif "—Ä—É—Å" in text or "rus" in text or "üá∑üá∫" in text:        new_lang = "ru"    elif "english" in text or "üá¨üáß" in text:        new_lang = "en"    else:        lang = await get_user_language(user_id)        return await message.answer(t("select_language", lang))    get_user_ref(user_id).update({'language': new_lang})    await message.answer(t("language_changed", new_lang), reply_markup=get_main_menu_keyboard(new_lang))    await state.clear()@dp.callback_query(lambda c: c.data == "edit_profile")async def edit_profile_callback(callback: types.CallbackQuery, state: FSMContext):    user_id = callback.from_user.id    lang = await get_user_language(user_id)    keyboard = InlineKeyboardMarkup(inline_keyboard=[        [InlineKeyboardButton(text=t("edit_name", lang), callback_data="edit_name")],        [InlineKeyboardButton(text=t("edit_age", lang), callback_data="edit_age")],        [InlineKeyboardButton(text=t("edit_goal", lang), callback_data="edit_goal")],        [InlineKeyboardButton(text=t("back_to_menu", lang), callback_data="cancel_edit")]    ])    await callback.message.edit_text(t("edit_which_field", lang), reply_markup=keyboard)    await state.set_state(EditProfileStates.selecting_field)@dp.callback_query(EditProfileStates.selecting_field)async def handle_profile_field_selection(callback: types.CallbackQuery, state: FSMContext):    user_id = callback.from_user.id    lang = await get_user_language(user_id)    field = callback.data    if field == "edit_name":        await state.set_state(EditProfileStates.editing_name)        await callback.message.answer(t("enter_new_value", lang))    elif field == "edit_age":        await state.set_state(EditProfileStates.editing_age)        await callback.message.answer(t("enter_new_value", lang))    elif field == "edit_goal":        await state.set_state(EditProfileStates.editing_goal)        await callback.message.answer(t("enter_new_value", lang))    elif field == "cancel_edit":        await state.clear()        await callback.message.answer(t("main_menu", lang), reply_markup=get_main_menu_keyboard(lang))    await callback.answer()@dp.message(EditProfileStates.editing_name)async def handle_new_name(message: types.Message, state: FSMContext):    user_id = message.from_user.id    lang = await get_user_language(user_id)    new_name = message.text.strip()    if 2 <= len(new_name) <= 50:        get_user_ref(user_id).update({'name': new_name})        await message.answer(t("profile_updated", lang))        await state.clear()        await cmd_menu(message)    else:        await message.answer(t("name_error", lang))@dp.message(EditProfileStates.editing_age)async def handle_new_age(message: types.Message, state: FSMContext):    user_id = message.from_user.id    lang = await get_user_language(user_id)    try:        new_age = int(message.text.strip())        if 0 <= new_age <= 120:            get_user_ref(user_id).update({'age': new_age})            await message.answer(t("profile_updated", lang))            await state.clear()            await cmd_menu(message)        else:            await message.answer(t("age_error", lang))    except ValueError:        await message.answer(t("age_error", lang))@dp.message(EditProfileStates.editing_goal)async def handle_new_goal(message: types.Message, state: FSMContext):    user_id = message.from_user.id    lang = await get_user_language(user_id)    new_goal = message.text.strip()    get_user_ref(user_id).update({'goal': new_goal})    await message.answer(t("profile_updated", lang))    await state.clear()    await cmd_menu(message)@dp.callback_query(lambda c: c.data == "edit_reminders")async def edit_reminders_callback(callback: types.CallbackQuery, state: FSMContext):    user_id = callback.from_user.id    lang = await get_user_language(user_id)    user_data = get_user_ref(user_id).get().to_dict()    water_status = t("reminder_enabled" if user_data.get('water_reminders', True) else "reminder_disabled", lang)    meal_status = t("reminder_enabled" if user_data.get('meal_reminders', True) else "reminder_disabled", lang)    keyboard = InlineKeyboardMarkup(inline_keyboard=[        [InlineKeyboardButton(text=t("toggle_water_reminders", lang), callback_data="toggle_water")],        [InlineKeyboardButton(text=t("toggle_meal_reminders", lang), callback_data="toggle_meal")],        [InlineKeyboardButton(text=t("back_to_menu", lang), callback_data="cancel_edit")]    ])    await callback.message.edit_text(        t("reminder_settings", lang).format(water_status=water_status, meal_status=meal_status),        reply_markup=keyboard    )    await state.set_state(EditRemindersStates.main_menu)@dp.callback_query(EditRemindersStates.main_menu)async def handle_reminder_toggle(callback: types.CallbackQuery, state: FSMContext):    user_id = callback.from_user.id    lang = await get_user_language(user_id)    action = callback.data    if action == "toggle_water":        current = get_user_ref(user_id).get().to_dict().get('water_reminders', True)        get_user_ref(user_id).update({'water_reminders': not current})        status = t("reminder_disabled" if current else "reminder_enabled", lang)        await callback.answer(f"Water reminders {status}")    elif action == "toggle_meal":        current = get_user_ref(user_id).get().to_dict().get('meal_reminders', True)        get_user_ref(user_id).update({'meal_reminders': not current})        status = t("reminder_disabled" if current else "reminder_enabled", lang)        await callback.answer(f"Meal reminders {status}")    elif action == "cancel_edit":        await state.clear()        await callback.message.answer(t("main_menu", lang), reply_markup=get_main_menu_keyboard(lang))    await edit_reminders_callback(callback, state)@dp.message(F.text.lower() == "‚öôÔ∏è settings")@dp.message(F.text.lower() == "‚öôÔ∏è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏")@dp.message(F.text.lower() == "‚öôÔ∏è sozlamalar")@dp.message(Command("settings"))async def show_settings(message: types.Message):    """Show settings menu"""    user_id = message.from_user.id    lang = await get_user_language(user_id)    settings_kb = InlineKeyboardMarkup(        inline_keyboard=[            [InlineKeyboardButton(text=t("change_language", lang), callback_data="change_language")],            [InlineKeyboardButton(text=t("edit_reminders", lang), callback_data="edit_reminders")],            [InlineKeyboardButton(text=t("edit_profile", lang), callback_data="edit_profile")]        ]    )    await message.answer(t("settings_title", lang), reply_markup=settings_kb)@dp.callback_query(lambda c: c.data.startswith("log_meal_text_"))async def callback_log_meal_text(callback_query: types.CallbackQuery, state: FSMContext):    """Handle meal logging through text via inline button"""    meal_type = callback_query.data.split('_')[-1]    user_id = callback_query.from_user.id    lang = await get_user_language(user_id)    await callback_query.answer()    await state.update_data(meal_type=meal_type)    await state.set_state(MealLogging.waiting_for_text)    await bot.send_message(        user_id,        f"Please describe what you ate for {meal_type}:",        reply_markup=ReplyKeyboardRemove()    )@dp.message(MealLogging.waiting_for_text)async def process_meal_text(message: types.Message, state: FSMContext):    """Process meal text input after callback"""    try:        user_id = message.from_user.id        lang = await get_user_language(user_id)        data = await state.get_data()        meal_type = data.get('meal_type', 'meal')        text = message.text.strip()        # Wait message        await message.answer(t("processing", lang))        # Language mapping for AI prompt        language_names = {            'en': 'English',            'ru': 'Russian',            'uz': 'Uzbek'        }        language = language_names.get(lang, 'English')        # Analyze with Gemini in the user's language        try:            response = nutrition_model.generate_content(                f"In {language}, provide nutritional info for {text} in format: 1) Calories 2) Protein 3) Carbs 4) Fat. Use emojis and short bullets."            )            analysis = response.text        except Exception as e:            logger.error(f"AI analysis error: {e}")            analysis = t("error_processing", lang)        # Store in Firestore        get_meals_ref(user_id).add({            'timestamp': datetime.now(pytz.utc),            'analysis': analysis,            'text_input': text,            'meal_type': meal_type        })        await message.answer(f"üìù <b>{meal_type.capitalize()} logged:</b>\n\n{analysis}",                             reply_markup=get_main_menu_keyboard(lang))        await state.clear()    except Exception as e:        logger.error(f"Text input error: {e}")        lang = await get_user_language(message.from_user.id)        await message.answer(t("error_processing", lang), reply_markup=get_main_menu_keyboard(lang))        await state.clear()@dp.callback_query(lambda c: c.data.startswith("log_meal_photo_"))async def callback_log_meal_photo(callback_query: types.CallbackQuery):    """Handle meal logging through photo via inline button"""    meal_type = callback_query.data.split('_')[-1]    user_id = callback_query.from_user.id    lang = await get_user_language(user_id)    await callback_query.answer()    await bot.send_message(        user_id,        f"Please send a photo of your {meal_type}.",        reply_markup=ReplyKeyboardRemove()    )@dp.message(F.text.lower() == "üçΩ log meal")@dp.message(F.text.lower() == "üçΩ –∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–∏–µ–º –ø–∏—â–∏")@dp.message(F.text.lower() == "üçΩ ovqat qayd etish")@dp.message(Command("log_meal"))async def log_meal_command(message: types.Message):    """Handle meal logging from menu button"""    user_id = message.from_user.id    lang = await get_user_language(user_id)    meals = [t("breakfast", lang), t("lunch", lang), t("dinner", lang), t("snack", lang)]    meal_kb = InlineKeyboardMarkup(        inline_keyboard=[            [                InlineKeyboardButton(text=meals[0], callback_data="log_meal_text_breakfast"),                InlineKeyboardButton(text=meals[1], callback_data="log_meal_text_lunch")            ],            [                InlineKeyboardButton(text=meals[2], callback_data="log_meal_text_dinner"),                InlineKeyboardButton(text=meals[3], callback_data="log_meal_text_snack")            ]        ]    )    await message.answer(t("select_meal_type", lang), reply_markup=meal_kb)@dp.message(F.photo)async def handle_photo(message: types.Message):    """Handle food photo submission"""    try:        user_id = message.from_user.id        lang = await get_user_language(user_id)        # Update user's last active timestamp        get_user_ref(user_id).update({            'last_active': datetime.now(pytz.utc)        })        # Processing message        processing_msg = await message.answer(t("processing", lang))        # Download photo        photo = message.photo[-1]  # Get the highest resolution photo        file_info = await bot.get_file(photo.file_id)        file_content = await bot.download_file(file_info.file_path)        # Read file content as bytes        img_bytes = file_content.read()        # Language mapping for AI prompt        language_names = {            'en': 'English',            'ru': 'Russian',            'uz': 'Uzbek'        }        language = language_names.get(lang, 'English')        # Analyze with Gemini in the user's language        try:            response = vision_model.generate_content([                f"In {language}, analyze this food and provide: 1) Food name 2) Calories 3) Protein 4) Carbs 5) Fat. Use emojis and concise format.",                {"mime_type": "image/jpeg", "data": img_bytes}            ])            analysis = response.text        except Exception as e:            logger.error(f"Vision API error: {e}")            analysis = t("error_processing", lang)        # Store in Firestore        get_meals_ref(user_id).add({            'timestamp': datetime.now(pytz.utc),            'analysis': analysis,            'photo_id': photo.file_id        })        # Delete processing message and send result        await bot.delete_message(chat_id=processing_msg.chat.id, message_id=processing_msg.message_id)        await message.answer(f"üì∏ <b>{t('food_analysis', lang)}:</b>\n\n{analysis}", reply_markup=get_main_menu_keyboard(lang))    except Exception as e:        logger.error(f"Photo processing error: {e}")        lang = await get_user_language(message.from_user.id)        await message.answer(t("error_processing", lang), reply_markup=get_main_menu_keyboard(lang))@dp.message(F.document)async def handle_document(message: types.Message):    """Handle image documents"""    try:        # Check if document is an image        if not message.document.mime_type.startswith('image/'):            return        user_id = message.from_user.id        lang = await get_user_language(user_id)        # Update user's last active timestamp        get_user_ref(user_id).update({            'last_active': datetime.now(pytz.utc)        })        # Processing message        processing_msg = await message.answer(t("processing", lang))        # Download document        file_id = message.document.file_id        file_info = await bot.get_file(file_id)        file_content = await bot.download_file(file_info.file_path)        # Read file content as bytes        img_bytes = file_content.read()        # Language mapping for AI prompt        language_names = {            'en': 'English',            'ru': 'Russian',            'uz': 'Uzbek'        }        language = language_names.get(lang, 'English')        # Analyze with Gemini in the user's language        try:            response = vision_model.generate_content([                f"In {language}, analyze this food and provide: 1) Food name 2) Calories 3) Protein 4) Carbs 5) Fat. Use emojis and concise format.",                {"mime_type": message.document.mime_type, "data": img_bytes}            ])            analysis = response.text        except Exception as e:            logger.error(f"Vision API error with document: {e}")            analysis = t("error_processing", lang)        # Store in Firestore        get_meals_ref(user_id).add({            'timestamp': datetime.now(pytz.utc),            'analysis': analysis,            'document_id': file_id        })        # Delete processing message and send result        await bot.delete_message(chat_id=processing_msg.chat.id, message_id=processing_msg.message_id)        await message.answer(f"üì∏ <b>{t('food_analysis', lang)}:</b>\n\n{analysis}", reply_markup=get_main_menu_keyboard(lang))    except Exception as e:        logger.error(f"Document processing error: {e}")        lang = await get_user_language(message.from_user.id)        await message.answer(t("error_processing", lang), reply_markup=get_main_menu_keyboard(lang))@dp.message(    lambda msg: msg.text and not msg.text.startswith('/') and not any(keyword in msg.text.lower() for keyword in [        "log water", "–∑–∞–ø–∏—Å–∞—Ç—å –≤–æ–¥—É", "suv qayd etish",        "my stats", "–º–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", "mening statistikam",        "settings", "–Ω–∞—Å—Ç—Ä–æ–π–∫–∏", "sozlamalar",        "log meal", "–∑–∞–ø–∏—Å–∞—Ç—å –ø—Ä–∏–µ–º –ø–∏—â–∏", "ovqat qayd etish",        "help", "–ø–æ–º–æ—â—å", "yordam"    ]))async def handle_text(message: types.Message, state: FSMContext):    """Handle food text descriptions"""    # Skip if we're in a state    current_state = await state.get_state()    if current_state is not None and current_state == MealLogging.waiting_for_text:        return    try:        user_id = message.from_user.id        lang = await get_user_language(user_id)        # Update user's last active timestamp        get_user_ref(user_id).update({            'last_active': datetime.now(pytz.utc)        })        text = message.text.strip()        # Processing message        processing_msg = await message.answer(t("processing", lang))        # Language mapping for AI prompt        language_names = {            'en': 'English',            'ru': 'Russian',            'uz': 'Uzbek'        }        language = language_names.get(lang, 'English')        # Analyze with Gemini in the user's language        try:            response = nutrition_model.generate_content(                f"In {language}, provide nutritional info for {text} in format: 1) Calories 2) Protein 3) Carbs 4) Fat. Use emojis and short bullets."            )            analysis = response.text        except Exception as e:            logger.error(f"AI analysis error: {e}")            analysis = t("error_processing", lang)        # Store in Firestore        get_meals_ref(user_id).add({            'timestamp': datetime.now(pytz.utc),            'analysis': analysis,            'text_input': text        })        # Delete processing message and send result        await bot.delete_message(chat_id=processing_msg.chat.id, message_id=processing_msg.message_id)        await message.answer(f"üìù <b>{t('food_analysis', lang)}:</b>\n\n{analysis}", reply_markup=get_main_menu_keyboard(lang))    except Exception as e:        logger.error(f"Text analysis error: {e}")        lang = await get_user_language(message.from_user.id)        await message.answer(t("error_processing", lang), reply_markup=get_main_menu_keyboard(lang))# ==================== Main ====================async def main():    # Initialize scheduler    scheduler.start()    try:        # Start polling        await dp.start_polling(bot)    finally:        # Proper shutdown        scheduler.shutdown()        await bot.session.close()if __name__ == "__main__":    logging.basicConfig(        level=logging.INFO,        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',        handlers=[            logging.FileHandler("bot.log"),            logging.StreamHandler()        ]    )    asyncio.run(main())